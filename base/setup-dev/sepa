#!/bin/bash
# sepa <action> fichier.sh
action=$1
shfile=$2
shname=$(basename "$shfile" .sh)
shdir=$(dirname "$shfile")

### Fonctions accessibles par le pkgbuild
gitco()
{
    git clone --depth 1 $1 src
}

gitversion()
{
    git log --raw -1 | grep 'Date:' | cut -d ' ' -f 5,6,8 | sed -e 's/ //g'
}

# Charger le fichier .sh
if [ "$action" != "unpacksrc" ]; then
    source $2
fi

# Aide
usage()
{
    echo "Logram Setup Packager - Helper tool to create packages"
    echo
    echo "Usage : $0 <action> <script.h>"
    echo "    - action    : one of the following actions"
    echo "    - script.sh : The script bundled with the package, or a .tlz file"
    echo
    echo "Actions :"
    echo "    - getsource    : Download the sourcecode of a package"
    echo "    - createsource : Create the .tlz of the package"
    echo "    - unpacksrc    : Unpack the source .tlz"
    echo "    - build        : Build a source package"
    echo "    - binaries     : Build binaries from a source package"
}

# Récupérer la source d'un pkgbuild
getsource()
{
    download
}

# Créer l'archive source prête à l'envoi
createsource()
{
    # Trouver la version
    if [ "$DEVEL" = "true" ]; then
        _v="devel"
    else
        _v=$VERSION
    fi
    
    # Lancer la commande
    tar --lzma -cf $SOURCE~$_v.src.tlz $shdir
}

# Décompresser un paquet source
unpacksrc()
{
    tar --lzma -xf $shfile
}

# Compiler
_build()
{
    if [ ! -d src ]; then
        getsource
    fi

    # Dossier temporaire
    mkdir -p build

    builddir="$PWD/build"

    (cd src && build $builddir)

    # Stripper
    find build -exec strip --strip-unneeded {} \; > /dev/null 2>&1
}

# Créer les paquets
binaries()
{
    if [ ! -d build ]; then
        _build
    fi

    # Explorer les binaires
    for binary in ${BINARIES[*]}; do
        echo -n ">> $binary..."
        
        # Créer un dossier temporaire
        mkdir -p tmp

        # Y copier tous les fichiers que le paquet veux
        while read f; do
            for fl in build$f; do
                mkdir -p $(dirname tmp/${fl:6})
                cp -rf $fl tmp/${fl:6}
            done
        done < "$shdir/$binary.files"

        # Copier les métadonnées
        mkdir -p tmp/__LOGRAM
        cp -r $shdir/* tmp/__LOGRAM

        # Trouver la version
        mv=$(cd src && version)
        export v=$(echo $VERSION | sed -e "s/{{VERSION}}/$mv/g")

        # Obtenir les dépendances
        export GUI="false"
        d_$binary
        
        # Obtenir la distribution dans laquelle le paquet va aller
        distro=$(cat $shdir/metadata.xml \
            | grep entry \
            | grep distribution \
            | head -n1 \
            | cut -d '"' -f 2)

        # Générer le fichier de contrôle pour Setup
        echo "[Binary]
Name=$binary
Version=$v
Source=$SOURCE
Maintainer=$MAINTAINER
Section=$SECTION
Distribution=$distro
License=$LICENSE
PrimaryLang=$PRIMARYLANG
Gui=$GUI
Depends=$DEPENDS
Provides=$PROVIDES
Replaces=$REPLACES
Suggest=$SUGGESTS
Conflicts=$CONFLICTS" > tmp/__LOGRAM/control

        # Compresser le tout dans un .tlz
        if [ "$ARCH" = "all" ]; then
            machine="all"
        else
            machine=$(uname -m)
        fi
        
        (cd tmp && tar --lzma -cf ../$binary~$v.$machine.tlz *)
        
        # Effacer le dossier temporaire
        rm -rf tmp

        echo " done"
    done
}

case $action in
    getsource)
        getsource
        ;;
    createsource)
        createsource
        ;;
    unpacksrc)
        unpacksrc
        ;;
    build)
        _build
        ;;
    binaries)
        binaries
        ;;
    *)
        usage
esac